lexer grammar AngularLexer;
IF: 'if';
ELSE: 'else';
FOR: 'for';
WHILE: 'while';
FUNCTION: 'function';
RETURN: 'return';
LET: 'let';
CONST: 'const';
CLASS: 'class';
INTERFACE: 'interface';
ENUM: 'enum';
EXTENDS: 'extends';
IMPLEMENTS: 'implements';
SUPER: 'super';
IMPORT: 'import';
EXPORT: 'export';
AS: 'as';
FROM: 'from';
NEW: 'new';
THIS: 'this';
PUBLIC: 'public';
PRIVATE: 'private';
PROTECTED: 'protected';
STATIC: 'static';
VOID: 'void';
TYPE: 'type';
TRY: 'try';
CATCH: 'catch';
FINALLY: 'finally';
THROW: 'throw';
SWITCH: 'switch';
CASE: 'case';
DEFAULT: 'default';
BREAK: 'break';
CONTINUE: 'continue';
DO: 'do';
EVENT: 'event';
DECORATOR: '@';
OF: 'of';
IN: 'in';
INSTANCEOF: 'instanceof';
AWAIT: 'await';
ASYNC: 'async';
YIELD: 'yield';
CONSTRUCTOR: 'constructor';
COMPONENT: 'component';
SERVICE: 'service';
PROPERTY: 'property';

ID: [a-zA-Z_$] [a-zA-Z0-9_$]*;

STRING: '"' ( ~["\\] | '\\' . )* '"' | '\'' ( ~['\\] | '\\' . )* '\'';
TEMPLATE_STRING: '`' ( ~[`\\] | '\\' . | '\\${' .*? '}' )* '`';
NUMBER: [0-9]+ ( '.' [0-9]+ )? ( [eE] [+-]? [0-9]+ )?;
HEX_NUMBER: '0x' [0-9a-fA-F]+;
OCTAL_NUMBER: '0o' [0-7]+;
BINARY_NUMBER: '0b' [01]+;
BOOLEAN: 'true' | 'false';
NULL: 'null';
UNDEFINED: 'undefined';
ASSIGN: '=';
PLUS: '+';
MINUS: '-';
MULTIPLY: '*';
DIVIDE: '/';
MODULO: '%';
POWER: '**';
EQUAL: '==';
STRICT_EQUAL: '===';
NOT_EQUAL: '!=';
STRICT_NOT_EQUAL: '!==';
LESS: '<';
GREATER: '>';
LESS_EQUAL: '<=';
GREATER_EQUAL: '>=';
AND: '&&';
OR: '||';
NOT: '!';
BITWISE_AND: '&';
BITWISE_OR: '|';
BITWISE_XOR: '^';
BITWISE_NOT: '~';
SHIFT_LEFT: '<<';
SHIFT_RIGHT: '>>';
UNSIGNED_SHIFT_RIGHT: '>>>';
ARROW: '=>';
OPTIONAL_CHAINING: '?.';
NULLISH_COALESCING: '??';
NULLISH_ASSIGN: '??=';
INCRES:'++';
DECRES:'--';
SEMICOLON: ';';
COMMA: ',';
DOT: '.';
ELLIPSIS: '...';
LPAREN: '(';
RPAREN: ')';
LBRACE: '{';
RBRACE: '}';
LBRACKET: '[';
RBRACKET: ']';
COLON: ':';
QUESTION: '?';
PIPE: '|';
BACKTICK: '`';

ANY: 'any';
NUMBER_TYPE: 'number';
STRING_TYPE: 'string';
BOOLEAN_TYPE: 'boolean';
VOID_TYPE: 'void';
UNKNOWN: 'unknown';
NEVER: 'never';

REGEX: '/' ( ~[/\\\r\n] | '\\' . )+ '/' [gimuy]*;

WS: [ \t]+ -> skip;
NEWLINE: ('\r'? '\n' | '\r') -> skip;
COMMENT: '//' ~[\r\n]* -> skip;
BLOCK_COMMENT: '/*' .*? '*/' -> skip;

ERROR: . ;
